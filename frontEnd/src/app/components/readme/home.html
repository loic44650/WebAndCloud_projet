<div class="content-wrapper">
  <section class="content" style="text-align:justify">
<h1>WebAndCloud_projet</h1>
<p>Ce qu&#39;il faudra pas oublier :</p>
<p>Un summary de l&#39;API avec un lien vers
  Résumé des tests avec des liens vers
  Détails d&#39;implémentations :   pourquoi message est comme ça, pourquoi messageIndex, user, expliquer ce qui est chiant avec la rétroactivité</p>
<h1>Projet Web &amp; Cloud</h1>
<p>Ceci est le dépot github associé à notre projet de web and cloud.</p>
<p>Jehanno Clément<br/>
  Phalavandishivli (dsl deme) Demetre <br/>
  Duclos Romain<br/>
  Mahier Loïc<br/></p>
<p>M1-ALMA 2017-2018<br/></p>
<h1>Plan</h1>
<ul>
  <li><p><a href='#presentation'>Présentation du sujet</a></p>
  </li>
  <li><p><a href='#details'>Détails d&#39;implémentation</a></p>
    <ul>
      <li><a href='#user'>User</a></li>
      <li><a href='#message'>Message</a></li>
      <li><a href='#messageIndex'>MessageIndex</a></li>

    </ul>
  </li>
  <li><p><a href='#Tests'>Tests</a></p>
  </li>
  <li><p><a href='#scale'>Scalability</a></p>
  </li>
  <li><p><a href='#conclusion'>Conclusion</a></p>
  </li>

</ul>
<h2><a name="presentation"></a>Présentation du sujet</h2>
<p>Le sujet est disponible <a href='https://docs.google.com/document/d/1wVf1dWzbmxp5wtJd_I9kAHpke29FpPqe8mPOCv3J1mM/edit#'>ici</a>.</p>
<h2><a name="details"></a> Détails d&#39;implémentation</h2>
<p>Dans cette section nous allons expliquer certaines de nos classes ainsi que quelques décisions que nous avons prises qui ont donc influencé la construction du code.</p>
<h3><a name="user"></a> La classe User</h3>
<p>Avant d&#39;aller plus loin il faut que nous expliquions comment la classe User est définie</p>
<!--<pre><code>@PersistenceCapable(identityType=IdentityType.APPLICATION)-->
<!--public class User {-->

	<!--@PrimaryKey-->
	<!--@Persistent(valueStrategy=IdGeneratorStrategy.IDENTITY)-->
	<!--Key key;-->

	<!--@Persistent-->
	<!--String name;-->

	<!--@Persistent-->
	<!--@Element(dependent=&quot;true&quot;)-->
	<!--Set&lt;Long&gt; lesGensQuiMeSuit = new HashSet&lt;Long&gt;();// les gens qui me follow-->

	<!--@Persistent-->
	<!--@Element(dependent=&quot;true&quot;)-->
    <!--Set&lt;Long&gt; lesGensQueJeSuit = new HashSet&lt;Long&gt;();-->
<!--}-->
<!--</code></pre>-->
<p>La classe User va contenir un nom d&#39;utilisateur et une clé pour l&#39;identifier de manière unique. <br/>
  Dans l&#39;idée on pourrait aussi rajouter une photo de profil, une description, etc. Tout ce qui est relatif à l&#39;utilisateur en lui-même.<br/>
  Les champs &quot;lesGensQueJeSuit&quot; et &quot;lesGensQuiMeSuit&quot; sont importants. Au premier abord on pourrait penser que uniquement le fait de suivre quelqu&#39;un est suffisant. Ainsi on aurait juste un champ &quot;lesGensQueJeSuit&quot;. Se pose ensuite la question de savoir &quot;A qui je dois envoyer un messsage quand je poste ?&quot;. <br/>
  La première idée implique que nous parcourions <strong>tous</strong> les utilisateurs de la base pour aller regarder dans leur liste de follows si il faut envoyer à cet utilisateur ou non. Sur l&#39;exemple de twitter, Rihanna a 84M d&#39;abonnés, twitter recense 330M d&#39;utilisateurs aux dernières nouvelles. <br/>
  Avec notre implémentation nous estimons qu&#39;il vaut mieux avoir une liste de 84M d&#39;abonnés qu&#39;en parcourir 330M a <strong>chaque</strong> fois, car la personne qui n&#39;a &quot;que&quot; 1M de follower, on va parcourir 1M au lieu de 330M. Encore une fois il s&#39;agit de perdre en taille pour gagner en temps d’exécution. <br/></p>
<h3><a name="message"></a> La classe Message</h3>
<p>Voici comment nous avons organisé notre classe Message :</p>
<!--<pre><code>public class Message {
</code></pre>
<pre><code>    @PrimaryKey-->
    <!--@Persistent(valueStrategy=IdGeneratorStrategy.IDENTITY)-->
    <!--private Key msgId;-->

    <!--@Persistent-->
    <!--private Long userId;-->

    <!--@Persistent-->
    <!--private String message;-->
<!--}-->
<!--</code></pre>-->
<p>Fondamentalement un message va contenir une clé comme identifiant unique ainsi que l&#39;id de l&#39;User qui posté ce message.
  La classe message ne sert que à envoyer du texte, on pourrait très bien y ajouter des photos, des gifs, des vidéos, etc. Qu&#39;importe.
  Cependant ce qui nous importe c&#39;est ce que nous avons vu dans la classe User : lorsqu&#39;un utilisateur poste un message il faut savoir à qui l&#39;envoyer, hors l&#39;information n&#39;est pas définie ici. Nous avons crée une classe messageIndex sur laquelle nous allons revenir car c&#39;est elle qui importe.</p>
<h3><a name="messageIndex"></a> La classe Message Index</h3>
<!--<pre><code>@PersistenceCapable(identityType=IdentityType.APPLICATION)-->
<!--public class MessageIndex{-->
	<!--@PrimaryKey-->
	<!--@Persistent(valueStrategy=IdGeneratorStrategy.IDENTITY)-->
	<!--Key k;-->

	<!--@Persistent-->
	<!--Message msg;-->

	<!--@Persistent-->
	<!--long timestamp;-->

	<!--@Persistent-->
    <!--Set&lt;Long&gt; receivers = new HashSet&lt;Long&gt;();-->
<!--}-->
<!--</code></pre>-->
<p>
    La classe messageIndex est primordiale pour scale. <br/>
  Nous avons vu en cours que ce qui nous importe c&#39;est que nos requêtes soient rapides et pour se faire il ne faut pas déseraliser et sérialiser l&#39;intégralité du message (body, photos, etc.) si vous êtes novices vous trouverez des informations complémentaires
  <a href='https://www.youtube.com/watch?v=AgaL6NGpkB8'>ici</a>. <br/>
  Donc il nous faut scale. C&#39;est pourquoi nous avons la classe messageIndex. Sauf que nous avons quelques petits détails supplémentaires, c&#39;est ce sur quoi nous allons revenir dans cette section. <br/>
  La clé est l&#39;identificateur unique ici. Le message quand à lui peut surprendre ici. En fait la relation de &quot;parenté&quot; dans le cloud définie par les entity groups (comme expliqué dans la vidéo plus haut) est gérée automatiquement par le JDO de cette manière. Une autre option consistait à définir deux entitées message et messageIndex puis les push en spécifiant que message est le parent de messageIndex, mais le JDO le fait et c&#39;est plus simple. <br/>
  Le timestamp nous permet juste de pouvoir faire les requêtes demandées quand on nous demande d&#39;afficher les 10 <strong>derniers</strong> messages il faut bien savoir quels sont ces 10 derniers donc on rajoute un long qui est géré à la création du message (cf code). <br/>
  Les receivers sont les personnes à qui sont destinés le message, c&#39;est pour ça qu&#39;on a besoin de la liste de qui nous follow dans User. Donc on se base sur ça et on n&#39;oublie pas de se rajouter afin de voir nos propores tweets (eh oui). <br/>
  Un autre petit détail : ici quand on parle du timestamp on met sous tapis le fait que en l&#39;état la requête ne fonctionne pas comme ça : pour savoir quels sont les 10 derniers messages d&#39;un utilisateur il faut bien 2 choses : les 10 <strong>derniers</strong> destiné à <strong>l&#39;utilisateur</strong> donc pour faire cette requête on a besoin d&#39;un index multivalué sur ces deux champs. <br/>
</p>
<h2><a name="API"></a> Tests</h2>
<p>&nbsp;</p>
<h2><a name="scale"></a> Scalability</h2>
<h4>Est-ce qu&#39;on scale ? <br/></h4>
<p>
  C&#39;est la question qu&#39;on se pose.
  La réponse est oui, clairement.
  Nos messages vont scales grâce à messageIndex en fait c&#39;est tout l&#39;intérêt de faire ça. Dans les faits il est possible de faire pareil pour nos users mais ici ce n&#39;est pas utile car notre utilisateur n&#39;a &quot;que&quot; un nom, si il avait une photo de profil, une description, une bannière, un site, etc. Il serait <del>intéressant</del> nécessaire de faire la même chose pour scale correctement.
</p>
  </section>
</div>
